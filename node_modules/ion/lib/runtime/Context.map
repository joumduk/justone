{"version":3,"sources":["Context.ion"],"names":["ion","Factory","Literal","noop",{"type":"Identifier","name":"noop","loc":{"start":{"line":6,"column":4,"fixed":true,"source":"ion/runtime/Context.ion"},"end":{"line":6,"column":8,"fixed":true,"source":"ion/runtime/Context.ion"}}},"Context","constructor","parent","output","depth","variables","root","_runtimes","returnExpression","properties","newContext","createRuntime","node","get","name","variable","getVariable","Error","value","context","global","cachedGlobals","globals","setVariableFromAst","setVariableExpression","setVariableLiteral","expression"],"mappings":"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","sourcesContent":["\nconst\n    ion = import '../'\n    Factory = import './Factory'\n    Literal = import './Literal'\n    noop = ->\n\nexport class Context\n    constructor: (parent, output) ->\n        # the output object that values are written to\n        @output = output\n        # parent is either null or another Context\n        @parent = parent\n        # calculate and set the depth\n        @depth = parent? ? parent.depth + 1 : 0\n        # an object that maps variable names to variable expressions\n        @variables = {}\n        # store a reference to the root context\n        @root = @parent?.root ? @\n        # runtime nodes keyed by toCode\n        @_runtimes = {}\n        # if there is a return expression, copy it\n        @returnExpression = parent?.returnExpression\n    properties:\n        newContext: (output = @output) -> new Context(@, output)\n        createRuntime: (node) ->\n            return Factory.createRuntime(@, node)\n        get: (name) ->\n            let variable = @getVariable(name)\n            if not variable?\n                throw new Error(\"Variable not found: '{{name}}'\")\n            return variable.value\n        getVariable: (name) ->\n            let context = @, value\n            while context?\n                let variable = context.variables[name]\n                if variable?\n                    return variable\n                context = context.parent\n            # if the variable is not defined by us then it is probably a global variable.\n            # we do however require that it be a globally defined variable, otherwise we throw an error.\n            value = global[name]\n            if value is undefined\n                throw new Error(\"Variable not found: '{{name}}'\")\n            # global values are considered to be constants.\n            # we could consider caching these values within the context.\n            let cachedGlobals = @root.globals ?= {}\n            return cachedGlobals[name] ?= new Literal({value})\n        setVariableFromAst: (name, node) ->\n            if name?\n                return @setVariableExpression(name, @createRuntime(node))\n        setVariableLiteral: (name, value) ->\n            if name?\n                return @setVariableExpression(name, new Literal({value}))\n        setVariableExpression: (name, expression) ->\n            if name?\n                if @variables[name]?\n                    throw new Error(\"Variable {{name}} is already defined\")\n                # we always watch the expression to make sure it is created only once\n                # if we don't, then it may be created and destroyed multiple times which can cause bugs\n                @variables[name] = expression\n                return expression\n"]}