{"version":3,"sources":["Context.ion"],"names":["ion","Factory","Literal","noop",{"type":"Identifier","name":"noop","loc":{"start":{"line":6,"column":4,"fixed":true,"source":"ion/runtime/Context.ion"},"end":{"line":6,"column":8,"fixed":true,"source":"ion/runtime/Context.ion"}}},"Context","constructor","parent","output","variables","root","_watched","_runtimes","properties","newContext","createRuntime","node","get","name","variable","getVariable","Error","value","context","global","cachedGlobals","globals","setVariableFromAst","setVariableExpression","setVariableLiteral","expression","watchValue"],"mappings":"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","sourcesContent":["\nconst\n    ion = import '../'\n    Factory = import './Factory'\n    Literal = import './Literal'\n    noop = ->\n\nexport class Context\n    constructor: (parent, output) ->\n        # the output object that values are written to\n        @output = output\n        # parent is either null or another Context\n        @parent = parent\n        # an object that maps variable names to variable expressions\n        @variables = {}\n        # store a reference to the root context\n        @root = @parent?.root ? @\n        # track which variables we have watched for get property\n        @_watched = {}\n        # runtime nodes keyed by toCode\n        @_runtimes = {}\n    properties:\n        newContext: (output = @output) -> new Context(@, output)\n        createRuntime: (node) ->\n            # if Factory.canCache(node)\n            #     let key = Factory.toCode(node)\n            #     if @_runtimes.hasOwnProperty(key)\n            #         return @_runtimes[key]\n            #     else\n            #         console.log('caching: ' + Factory.toCode(node))\n            #         return @_runtimes[key] = Factory.createRuntime(@, node)\n            # else\n            return Factory.createRuntime(@, node)\n        get: (name) ->\n            let variable = @getVariable(name)\n            if not variable?\n                throw new Error(\"Variable not found: '{{name}}'\")\n            return variable.value\n        getVariable: (name) ->\n            let context = @, value\n            while context?\n                let variable = context.variables[name]\n                if variable?\n                    return variable\n                context = context.parent\n            # if the variable is not defined by us then it is probably a global variable.\n            # we do however require that it be a globally defined variable, otherwise we throw an error.\n            value = global[name]\n            if value is undefined\n                throw new Error(\"Variable not found: '{{name}}'\")\n            # global values are considered to be constants.\n            # we could consider caching these values within the context.\n            let cachedGlobals = @root.globals ?= {}\n            return cachedGlobals[name] ?= new Literal({value})\n        setVariableFromAst: (name, node) ->\n            if name?\n                @setVariableExpression(name, @createRuntime(node))\n        setVariableLiteral: (name, value) ->\n            if name?\n                @setVariableExpression(name, new Literal({value}))\n        setVariableExpression: (name, expression) ->\n            if name?\n                # we always watch the expression to make sure it is created only once\n                # if we don't, then it may be created and destroyed multiple times which can cause bugs\n                expression.watchValue(noop)\n                return @variables[name] = expression\n"]}