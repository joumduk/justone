{"version":3,"sources":["astFunctions.ion"],"names":["ion","addStatement",{"type":"Identifier","name":"addStatement","loc":{"start":{"line":4,"column":4,"fixed":true,"source":"ion/compiler/astFunctions.ion"},"end":{"line":4,"column":16,"fixed":true,"source":"ion/compiler/astFunctions.ion"}}},"node","statement","index","offset","body","type","Array","isArray","indexOf","Math","max","min","length","splice","forEachDestructuringAssignment","pattern","expression","callback","properties","key","value","object","property","computed","elements"],"mappings":"aAAA;AACO,IACHA,GAAA,G,QAAAA,G,UAAM,CAAO,KAAP,CADH,EAEHC,YAAA,G,QAAAA,Y,GAAeC,UAACC,IAADD,EAAOE,SAAPF,EAAkBG,KAAlBH,EAAyBI,MAAzBJ,EACnB;AAAA,QAAQ,IAAIK,IAAA,GAAOJ,IAAA,CAAKI,IAAhB,CAAR;AAAA,QACQ,IAAGA,IAAA,CAAKC,IAAL,K,gBAAH,EACR;AAAA,YAAYD,IAAA,GAAOA,IAAA,CAAKA,IAAZ,CAAZ;AAAA,SADQ,MAEK,IAAG,CAAIE,KAAA,CAAMC,OAAN,CAAcH,IAAd,CAAP,EACb;AAAA,YAAYJ,IAAA,CAAKI,IAAL,GAAW;AAAA,gBACPC,IAAA,E,gBADO;AAAA,gBAEPD,IAAA,EAAMA,IAAA,GAAO,CAACJ,IAAA,CAAKI,IAAN,CAFN;AAAA,aAAX,CAAZ;AAAA,SAJA;AAAA,QASQ,IAAG,C,CAAIF,K,SAAP,EACR;AAAA,YAAYA,KAAA,GAAQ,CAAR,CAAZ;AAAA,SADQ,MAEK,IAAGA,KAAA,CAAMG,I,QAAT,EACb;AAAA,YAAYH,KAAA,GAAQE,IAAA,CAAKI,OAAL,CAAaN,KAAb,I,CAAuBC,M,WAAAA,M,GAAS,C,CAAxC,CAAZ;AAAA,SAZA;AAAA,QAaQD,KAAA,GAAQO,IAAA,CAAKC,GAAL,CAAS,CAAT,EAAYD,IAAA,CAAKE,GAAL,CAAST,KAAT,EAAgBE,IAAA,CAAKQ,MAArB,CAAZ,CAAR,CAbR;AAAA,QAcQR,IAAA,CAAKS,MAAL,CAAYX,KAAZ,EAAmB,CAAnB,EAAsBD,SAAtB,EAdR;AAAA,KAHO,EAsBHa,8BAAA,G,QAAAA,8B,GAAiCf,UAACgB,OAADhB,EAAUiB,UAAVjB,EAAsBkB,QAAtBlB,EACrC;AAAA,QAAQ,IAAGgB,OAAA,CAAQV,IAAR,KAAgB,YAAnB,EACR;AAAA,YAAYY,QAAA,CAASF,OAAT,EAAkBC,UAAlB,EAAZ;AAAA,SADQ,MAEK,IAAGD,OAAA,CAAQG,U,QAAX,EACb;AAAA,Y;2BAA+BH,OAAA,CAAQG,U;yDACvC;AAAA,oB,qBAAA;AAAA,oB,IADiBC,G,SAAAA,G,CACjB;AAAA,oB,IADqBC,K,SAAAA,K,CACrB;AAAA,oBAAgBN,8BAAA,CACIM,KADJ,EAEI;AAAA,wBACIf,IAAA,EAAM,kBADV;AAAA,wBAEIgB,MAAA,EAAQL,UAFZ;AAAA,wBAGIM,QAAA,EAAUH,GAHd;AAAA,wBAIII,QAAA,EAAUJ,GAAA,CAAId,IAAJ,KAAc,YAJ5B;AAAA,qBAFJ,EAOIY,QAPJ,EAAhB;AAAA,iB;aADA;AAAA,SADa,MAWA,IAAGF,OAAA,CAAQS,Q,QAAX,EACb;AAAA,Y;4BAAgCT,OAAA,CAAQS,Q;6DACxC;AAAA,oB,IADuBtB,K,OACvB;AAAA,oB,IADgBkB,K,cAChB;AAAA,oBAAgBN,8BAAA,CACIM,KADJ,EAEI;AAAA,wBACIf,IAAA,EAAM,kBADV;AAAA,wBAEIgB,MAAA,EAAQL,UAFZ;AAAA,wBAGIM,QAAA,EAAS;AAAA,4BACLjB,IAAA,EAAM,SADD;AAAA,4BAELe,KAAA,EAAOlB,KAFF;AAAA,yBAHb;AAAA,wBAMIqB,QAAA,EAAU,IANd;AAAA,qBAFJ,EASIN,QATJ,EAAhB;AAAA,iB;aADA;AAAA,SAdA;AAAA,KAvBO","sourcesContent":["\nexport const\n    ion = import '../'\n    addStatement = (node, statement, index, offset) ->\n        let body = node.body\n        if body.type is \"BlockStatement\"\n            body = body.body\n        else if not Array.isArray(body)\n            node.body =\n                type: \"BlockStatement\"\n                body: body = [node.body]\n\n        # clamp index from zero to length\n        if not index?\n            index = 0\n        else if index.type?\n            index = body.indexOf(index) + (offset ? 1)\n        index = Math.max(0, Math.min(index, body.length))\n        body.splice(index, 0, statement)\n\n    # traverses the pattern and finds every destructuring assignment\n    # the first callback argument is the identifier to assign to\n    # the second callback argument is the expression used to extract the value\n    forEachDestructuringAssignment = (pattern, expression, callback) ->\n        if pattern.type is 'Identifier'\n            callback(pattern, expression)\n        else if pattern.properties?\n            for {key,value} in pattern.properties\n                forEachDestructuringAssignment(\n                    value\n                    {}\n                        type: 'MemberExpression'\n                        object: expression\n                        property: key\n                        computed: key.type isnt 'Identifier'\n                    callback\n                )\n        else if pattern.elements?\n            for value, index in pattern.elements\n                forEachDestructuringAssignment(\n                    value\n                    {}\n                        type: 'MemberExpression'\n                        object: expression\n                        property:\n                            type: 'Literal'\n                            value: index\n                        computed: true\n                    callback\n                )\n\n"]}