{"version":3,"sources":["common.ion"],"names":["ion","lineDelimiter","isEmpty",{"type":"Identifier","name":"isEmpty","loc":{"start":{"line":5,"column":4,"fixed":true,"source":"ion/compiler/common.ion"},"end":{"line":5,"column":11,"fixed":true,"source":"ion/compiler/common.ion"}}},"s","length","trim","trimRight","replace","indentToken","outdentToken","splitLines","split","joinLines","array","join","getIndent","regex","exec","Number","MAX_VALUE","unindentString","sourceMapping","lines","minIndent","unindentLines","columnOffset","getMinIndent","line","Math","min","i","substring"],"mappings":"aAAA;AACA,IACIA,GAAA,G,OAAM,CAAO,KAAP,CADV,EAEIC,aAAA,GAAgB,IAFpB,EAGIC,OAAA,GAAUC,UAACC,CAADD,E;eAAO,C,CAAIC,C,SAAJ,IAAUA,CAAA,CAAEC,MAAF,KAAY,CAAtB,I,CAA2BD,CAAA,CAAEE,I,WAAFF,CAAA,CAAEE,IAAF,GAAUD,M,UAAV,KAAoB,C;KAHpE,EAIIE,SAAA,GAAYJ,UAACC,CAADD,E;eAAOC,CAAA,CAAEI,OAAF,CAAU,aAAV,EAAyB,EAAzB,C;KAJvB,CADA;AAOO,IACHC,WAAA,G,QAAAA,W,GAAc,MADX,EAEHC,YAAA,G,QAAAA,Y,GAAe,MAFZ,EAGHC,UAAA,G,QAAAA,U,GAAaR,UAACC,CAADD,E;eAAOC,CAAA,CAAEQ,KAAF,CAAQX,aAAR,C;KAHjB,EAIHY,SAAA,G,QAAAA,S,GAAYV,UAACW,KAADX,E;eAAWW,KAAA,CAAMC,IAAN,CAAWd,aAAX,C;KAJpB,EAKHe,SAAA,G,QAAAA,S,GAAYb,UAACC,CAADD,EAAIc,KAAJd,EAChB;AAAA,QAAQc,KAAA,GAAAA,K,WAAAA,K,GAAS,SAAT,CAAR;AAAA,QACQ,O,CAAOA,KAAA,CAAMC,IAAN,CAAWd,CAAX,C,WAAAa,KAAA,CAAMC,IAAN,CAAWd,CAAX,EAAe,CAAf,EAAkBC,M,qBAAlBY,KAAA,CAAMC,IAAN,CAAWd,CAAX,EAAe,CAAf,EAAkBC,M,GAASc,MAAA,CAAOC,SAAzC,CADR;AAAA,KANO,EAQHC,cAAA,G,QAAAA,c,GAAiBlB,UAACC,CAADD,EAAImB,aAAJnB,EACrB;AAAA,QAAQ,IAAIoB,KAAA,GAAQZ,UAAA,CAAWJ,SAAA,CAAUH,CAAV,CAAX,CAAZ,CAAR;AAAA,QACQ,IAAIoB,SAAA,GAAYC,aAAA,CAAcF,KAAd,CAAhB,CADR;AAAA,QAEQ,IAAGD,a,QAAH,EACR;AAAA,YAAYA,aAAA,CAAcI,YAAd,GAA6BF,SAA7B,CAAZ;AAAA,SAHA;AAAA,QAIQ,OAAOX,SAAA,CAAUU,KAAV,CAAP,CAJR;AAAA,KATO,EAcHI,YAAA,G,QAAAA,Y,GAAexB,UAACoB,KAADpB,EAAQc,KAARd,EACnB;AAAA,QAAQ,IAAIqB,SAAA,GAAYL,MAAA,CAAOC,SAAvB,CAAR;AAAA,Q,sBACoBG,K,eACpB;AAAA,Y,IADYK,I,GAAQL,K,KACpB;AAAA,YAAY,IAAG,OAAOK,IAAP,KAAe,QAAf,IAA4B,CAAI1B,OAAA,CAAQ0B,IAAR,CAAnC,EACZ;AAAA,gBAAgBJ,SAAA,GAAYK,IAAA,CAAKC,GAAL,CAASN,SAAT,EAAoBR,SAAA,CAAUY,IAAV,EAAgBX,KAAhB,CAApB,CAAZ,CAAhB;AAAA,aADA;AAAA,SAFA;AAAA,QAIQ,OAAOO,SAAP,CAJR;AAAA,KAfO,EAoBHC,aAAA,G,QAAAA,a,GAAgBtB,UAACoB,KAADpB,EACpB;AAAA,QAAQ,IAAIqB,SAAA,GAAYG,YAAA,CAAaJ,KAAb,CAAhB,CAAR;AAAA,Q,wBACuBA,K,gBACvB;AAAA,Y,IADkBQ,C,OAClB;AAAA,Y,IADYH,I,GAAWL,K,MACvB;AAAA,YAAY,IAAG,OAAOK,IAAP,KAAe,QAAlB,EACZ;AAAA,gBAAgBL,KAAA,CAAMQ,CAAN,IAAW7B,OAAA,CAAQ0B,IAAR,IAAgB,EAAhB,GAAqBA,IAAA,CAAKI,SAAL,CAAeR,SAAf,CAAhC,CAAhB;AAAA,aADA;AAAA,SAFA;AAAA,QAIQ,OAAOA,SAAP,CAJR;AAAA,KArBO","sourcesContent":["\nconst\n    ion = import '../'\n    lineDelimiter = '\\n'\n    isEmpty = (s) -> not s? or s.length is 0 or s.trim?().length is 0\n    trimRight = (s) -> s.replace(/[\\s\\xA0]+$/g, '')\n\nexport const\n    indentToken = '{{{{'\n    outdentToken = '}}}}'\n    splitLines = (s) -> s.split(lineDelimiter)\n    joinLines = (array) -> array.join(lineDelimiter)\n    getIndent = (s, regex) ->\n        regex ?= /^([ ]*)/\n        return regex.exec(s)?[1].length ? Number.MAX_VALUE\n    unindentString = (s, sourceMapping) ->\n        let lines = splitLines(trimRight(s))\n        let minIndent = unindentLines(lines)\n        if sourceMapping?\n            sourceMapping.columnOffset = minIndent\n        return joinLines(lines)\n    getMinIndent = (lines, regex) ->\n        let minIndent = Number.MAX_VALUE\n        for line in lines\n            if typeof line is 'string' and not isEmpty(line)\n                minIndent = Math.min(minIndent, getIndent(line, regex))\n        return minIndent\n    unindentLines = (lines) ->\n        let minIndent = getMinIndent(lines)\n        for line, i in lines\n            if typeof line is 'string'\n                lines[i] = isEmpty(line) ? '' : line.substring(minIndent)\n        return minIndent\n"]}