{"version":3,"sources":["Property.ion"],"names":["ion","Statement","Property","properties","activate",{"type":"Identifier","name":"activate","loc":{"start":{"line":7,"column":8,"fixed":true,"source":"ion/runtime/Property.ion"},"end":{"line":7,"column":16,"fixed":true,"source":"ion/runtime/Property.ion"}}},"keyExpression","context","createRuntime","computed","key","name","value","valueExpression","unobserveKey","observe","keyWatcher","setLeftValue","currentValue","output","get","keyValue","setProperty","unobserveValue","valueWatcher","valueValue","deactivate","hasOwnProperty","operator"],"mappings":"aAAA;AAAA,IACIA,GAAA,G,OAAM,CAAO,KAAP,CADV,EAEIC,SAAA,G,OAAY,CAAO,aAAP,CAFhB;IAIaC,Q;;QACTC,UAAA,EAAW;AAAA,YACPC,QAAA,EAAUC,YAClB;AAAA,gB,yBADQD,Q,uBACI,CAAZ;AAAA,gBAEY,KAACE,aAAD,QAACA,a,WAAD,KAACA,a,GAAiB,KAACC,OAAD,CAASC,aAAT,CAAuB,KAACC,QAAD,GAAY,KAACC,GAAb,GAAoB,KAACA,GAAD,CAAKC,I,WAAL,KAACD,GAAD,CAAKC,I,GAAO,KAACD,GAAD,CAAKE,KAA5D,CAAlB,CAFZ;AAAA,gBAGY,KAACC,eAAD,QAACA,e,WAAD,KAACA,e,GAAmB,KAACN,OAAD,CAASC,aAAT,CAAuB,KAACI,KAAxB,CAApB,CAHZ;AAAA,gBAMY,KAACE,YAAD,GAAgB,KAACR,aAAD,CAAeS,OAAf,CACZ,KAACC,UAAD,QAACA,U,WAAD,KAACA,U,YAAc,UAACN,GAAD,EAC/B;AAAA,oBAAoB,IAAGA,G,QAAA,IAAS,KAACG,eAAD,CAAiBI,Y,QAA7B,EAGpB;AAAA,wBAAwB,IAAIC,YAAA,GAAe,KAACX,OAAD,CAASY,MAAT,GAAkB,KAACZ,OAAD,CAASY,M,WAAT,KAACZ,OAAD,CAASY,MAAT,CAAiBT,GAAjB,C,SAAlB,GAA0C,KAACH,OAAD,CAASa,GAAT,CAAaV,GAAb,CAA7D,CAAxB;AAAA,wBACwB,IAAGQ,Y,QAAH,EACxB;AAAA,4BAA4B,KAACL,eAAD,CAAiBI,YAAjB,CAA8BC,YAA9B,EAA5B;AAAA,yBAFA;AAAA,qBAHA;AAAA,oBAMoB,KAACG,QAAD,GAAYX,GAAZ,CANpB;AAAA,oBAOoB,KAACY,WAAD,GAPpB;AAAA,iB,OAF4B,CAAhB,CANZ;AAAA,gBAiBY,KAACC,cAAD,GAAkB,KAACV,eAAD,CAAiBE,OAAjB,CACd,KAACS,YAAD,QAACA,Y,WAAD,KAACA,Y,YAAgB,UAACZ,KAAD,EACjC;AAAA,oBAAoB,KAACa,UAAD,GAAcb,KAAd,CAApB;AAAA,oBACoB,KAACU,WAAD,GADpB;AAAA,iB,OAF8B,CAAlB,CAjBZ;AAAA,aAFe;AAAA,YAwBPI,UAAA,EAAYrB,YACpB;AAAA,gB,yBADQqB,U,uBACI,CAAZ;AAAA,gBACY,KAACZ,YAAD,GADZ;AAAA,gBAEY,KAACS,cAAD,GAFZ;AAAA,aAzBe;AAAA,YA4BPD,WAAA,EAAajB,UAACK,GAADL,EAAkBO,KAAlBP,EAErB;AAAA,gB,IAFsBK,G;oBAAAA,G,GAAM,KAACW,Q,CAE7B;AAAA,gB,IAFuCT,K;oBAAAA,K,GAAQ,KAACa,U,CAEhD;AAAA,gBAAY,IAAG,KAACE,cAAD,CAAgB,UAAhB,KAAgC,KAACA,cAAD,CAAgB,YAAhB,CAAnC,EACZ;AAAA,oBAAgB,IAAGjB,G,QAAA,IAAS,KAACH,OAAD,CAASY,M,QAArB,EAChB;AAAA,wBAAoB,IAAID,YAAA,GAAe,KAACX,OAAD,CAASY,MAAT,CAAgBT,GAAhB,CAAnB,CAApB;AAAA,wBAEoB,IAAGQ,YAAA,KAAkBN,KAAlB,IAA6B,CAAAA,KAAA,KAAW,MAAX,IAAwB,KAACC,eAAD,CAAiBe,QAAjB,KAA6B,MAArD,CAAhC,EACpB;AAAA,4BAAwB,KAACrB,OAAD,CAASY,MAAT,CAAgBT,GAAhB,IAAuBE,KAAvB,CAAxB;AAAA,yBAHA;AAAA,qBADA;AAAA,iBADA;AAAA,aA9Be;AAAA,S;OADeX,S,EAJ9B;2BAIaC,Q","sourcesContent":["const\n    ion = import '../'\n    Statement = import './Statement'\n\nexport class Property extends Statement\n    properties:\n        activate: ->\n            super\n            # create the runtime expressions\n            @keyExpression ?= @context.createRuntime(@computed ? @key : (@key.name ? @key.value))\n            @valueExpression ?= @context.createRuntime(@value)\n            # then observe them, this way, the keywatcher can set the left value on the right hand side\n            # before it is activated\n            @unobserveKey = @keyExpression.observe(\n                @keyWatcher ?= (key) =>\n                    if key? and @valueExpression.setLeftValue?\n                        # if there is a context.output then get the current key from that\n                        # otherwise the key is probably referring to a variable\n                        let currentValue = @context.output ? @context.output?[key] : @context.get(key)\n                        if currentValue?\n                            @valueExpression.setLeftValue(currentValue)\n                    @keyValue = key\n                    @setProperty()\n            )\n            @unobserveValue = @valueExpression.observe(\n                @valueWatcher ?= (value) =>\n                    @valueValue = value\n                    @setProperty()\n            )\n        deactivate: ->\n            super\n            @unobserveKey()\n            @unobserveValue()\n        setProperty: (key = @keyValue, value = @valueValue) ->\n            # we must have a key, and the value must not be undefined UNLESS the value is explicitly undefined!\n            if @hasOwnProperty('keyValue') and @hasOwnProperty('valueValue')\n                if key? and @context.output?\n                    let currentValue = @context.output[key]\n                    # we never assign undefined UNLESS it's explicit using the void operator\n                    if currentValue isnt value and (value isnt undefined or @valueExpression.operator is 'void')\n                        @context.output[key] = value\n\n"]}