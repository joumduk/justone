const
    ion = import './'
    isObject = (a) ->
        let type = typeof a
        return a? and type is 'object' or type is 'function'
    deleteValue = null
    isPrivate = (name) -> name[0] is '_'

export const
    canSetProperty = (object, key) -> not (typeof object is 'function' and key is 'name')
    # options:
    #   deleteNull: delete properties if value is null, default: true
    #   factory: function to use when constructing new objects, defaults to using plain objects {}
    merge = (target, values, options) ->
        let deleteNull = options?.deleteNull ? true
        if values?.constructor isnt Object
            return values
        if not isObject(target)
            if options?.factory?
                target = options.factory(values)
            else
                target = {}
        for key, value of values
            if deleteNull and value is deleteValue
                delete target[key]
            else
                let newValue = merge(target[key], value, options)
                if canSetProperty(target, key)
                    target[key] = newValue
        return target
    # combines two patches to make a single patch
    combine = (patch1, patch2) -> merge(patch1, patch2, {deleteNull:false})
    # watches object for changes and calls the handler with patches
    watch = (object, handler, priority) ->
        if not isObject(object)
            throw new Error("Cannot watch: #{object}")
        watch.count = (watch.count ? 0) + 1
        # watch.objects ?= []
        # watch.objects.push(object)
        let watching = true
        let propertyWatchers = {}
        let watchProperties = (changes) ->
            let properties = changes?.map((a) -> a.name) ? Object.keys(object)
            for name in properties
                do (name) ->
                    if watching
                        propertyWatchers[name]?()
                        let value = object[name]
                        if isObject(value)
                            propertyWatchers[name] = watch(
                                value
                                (patch) ->
                                    handler({[name]:patch})
                                priority
                            )
                        else
                            delete propertyWatchers[name]

        watchProperties(null)
        let unobserve = ion.observe(
            object
            (changes) ->
                if watching
                    let patch = null
                    for {name} in changes
                        # we ignore names that start with underscore, they are considered private
                        if not isPrivate(name)
                            patch ?= {}
                            # we convert undefined values from delete into explicit nulls
                            patch[name] = object[name] ? deleteValue
                    watchProperties(changes)
                    if patch?
                        handler(patch)
        )
        return ->
            watch.count--
            # watch.objects.remove(object)
            watching = false
            unobserve()
            unobserve = null
            for key, unwatch of propertyWatchers
                unwatch()
            propertyWatchers = null

    # watch = (object, handler, priority = 0, callInitial = true) ->
    #     if callInitial
    #         watch.count = (watch.count ? 0) + 1
    #     if not isObject(object)
    #         throw new Error("Cannot watch: #{object}")
    #     # recurse watching and unwatching
    #     let subWatchers = {}
    #     # pending patch allows several changes at simultaneous levels of the
    #     # heirarchy to be combined into a single patch call
    #     let pendingPatch = null
    #     let processPatch = (patchValues) ->
    #         # watch sub objects
    #         for name of patchValues
    #             # unwatch any current value being watched
    #             # now watch sub values if we can
    #             subWatchers[name]?()
    #             let value = object[name]
    #             if isObject(value)
    #                 do (name) ->
    #                     let subHandler = (patch) ->
    #                         queuePatch({[name]:patch})
    #                     subWatchers[name] = watch(value, subHandler, priority, false)
    #     let pendingTimeout = null
    #     let queuePatch = (patch) ->
    #         # console.log(JSON.stringify(patch))
    #         if not callInitial
    #             handler(patch)
    #         else
    #             pendingPatch = combine(pendingPatch, patch)
    #             processPatch(pendingPatch)
    #             pendingTimeout ?= setTimeout(
    #                 ->
    #                     handler(pendingPatch)
    #                     pendingPatch = null
    #                     pendingTimeout = null
    #                 0
    #             )
    #     let watcher = (changes) ->
    #         let patch = null
    #         for change in changes
    #             # we ignore names that start with underscore, they are considered private
    #             if change.name[0] isnt '_'
    #                 patch ?= {}
    #                 # we convert undefined values from delete into explicit nulls
    #                 patch[change.name] = object[change.name] ? deleteValue
    #         if patch?
    #             queuePatch(patch)
    #     # if DEBUG
    #     #     let innerWatcher = watcher
    #     #     watcher = (changes) ->
    #     #         try
    #     #             innerWatcher(changes)
    #     #         catch e
    #     #             # catch and log errors, because object observe callbacks suppress errors
    #     #             console.error(e)

    #     # call process patch on the object to watch children
    #     processPatch(object)
    #     let unobserve = ion.observe(object, watcher, {priority})
    #     # return an function that lets us unwatch
    #     return ->
    #         if callInitial
    #             watch.count--
    #         try
    #             unobserve()
    #             # unwatch subWatchers
    #             for key, value of subWatchers
    #                 value()
    #         catch e
    #             console.error('Error in mergePatch unwatch')
    diff = (oldValue, newValue) ->
        # returns a patch which can convert from the oldValue to the newValue
        # returns undefined if there is no difference between them
        # the patch SHOULD be treated as readonly, since it may reference pre-existing objects
        if oldValue is newValue
            return undefined
        if not(oldValue? and newValue? and typeof newValue is 'object' and typeof oldValue is 'object')
            return newValue ? null
        let patch = undefined
        for name of oldValue if oldValue.hasOwnProperty(name)
            let propertyDiff = diff(oldValue[name], newValue[name])
            if propertyDiff isnt undefined
                patch ?= {}
                patch[name] = propertyDiff
        for name of newValue if newValue.hasOwnProperty(name) and not oldValue.hasOwnProperty(name)
            patch ?= {}
            patch[name] = newValue[name]
        return patch
    isChange = (oldValue, newValue) ->
        # returns true if a newValue will change the old value
        # returns false if a newValue will not change the old value
        if oldValue is newValue
            return false
        if not (oldValue? and newValue? and typeof newValue is 'object' and typeof oldValue is 'object')
            return true
        for name of newValue
            if newValue[name] is null and not oldValue.hasOwnProperty(name)
                continue
            if isChange(oldValue[name], newValue[name])
                return true
        return false
    test = do ->
        const equal = (a, b) -> not isChange(a, b) and not isChange(b, a)
        return
            merge: ->
                assert equal({a:{b:2,c:3},d:4}, merge({a:{b:2}}, {a:{c:3},d:4}))
                assert equal({b:2}, merge(null, {b:2}))
                assert equal({a:1,b:2}, merge({a:1,b:2,c:3}, {c:undefined}))
                let double = (x) -> x * 2
                assert equal({a:double}, merge({},{a:double}))
            isChange: ->
                assert isChange({a:1}, null)
                assert not isChange(null, null)
                assert isChange(undefined, null)
                assert isChange(null, undefined)
                assert not isChange({a:1}, {a:1})
                assert not isChange({a:{b:2,c:3}}, {a:{b:2}})
                assert isChange({a:{b:2}}, {a:{b:3}})
                assert not isChange({a:1}, {b:null})
            diff: ->
                assert equal({b:2}, diff({a:1}, {a:1,b:2}))
                assert equal({a:{b:3,c:null}}, diff({a:{b:2,c:4}}, {a:{b:3}}))
                assert equal({a:1}, diff(null, {a:1}))
                assert equal({c:{d:{f:4}}}, diff({a:1,b:2,c:{d:{e:1,f:2}}}, {a:1,b:2,c:{d:{e:1,f:4}}}))
                assert equal(null, diff({a:1}, undefined))
                assert equal(null, diff({a:1}, null))
                assert equal(undefined, diff({a:{b:2}}, {a:{b:2}}))
            observe: (done) ->
                if not Object.observe?
                    return done(null, "Object.observe missing.")
                let source =
                    name: 'Kris'
                    age: 41
                    children: 
                        Sadera:
                            grandchildren:
                                One: 1
                                Two: 2
                        Orion: {}
                        Third: {}
                let target = ion.clone(source, true)
                let unwatch = watch(
                    source
                    (patch) ->
                        target = merge(target, patch)
                        # should be immediate assert
                        if equal(source, target)
                            done()
                            unwatch()
                )
                source:
                    name: 'Fred'
                    children:
                        Orion:
                            a: 1
                            b: 2
                            c: 12
                        Sadera:
                            grandchildren:
                                three: 3
                # todo: delete a property in a literal?
                delete source.children.Third
                # temp requirement
                ion.checkForChanges()
