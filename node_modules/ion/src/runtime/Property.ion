const
    ion = import '../'
    Statement = import './Statement'

export class Property extends Statement
    properties:
        activate: ->
            super
            # create the runtime expressions
            @keyExpression ?= @context.createRuntime(@computed ? @key : (@key.name ? @key.value))
            @valueExpression ?= @context.createRuntime(@value)
            # then observe them, this way, the keywatcher can set the left value on the right hand side
            # before it is activated
            @unobserveKey = @keyExpression.observe(
                @keyWatcher ?= (key) =>
                    if key? and @valueExpression.setLeftValue?
                        # if there is a context.output then get the current key from that
                        # otherwise the key is probably referring to a variable
                        let currentValue = @context.output ? @context.output?[key] : @context.get(key)
                        if currentValue?
                            @valueExpression.setLeftValue(currentValue)
                    @keyValue = key
                    @setProperty()
            )
            @unobserveValue = @valueExpression.observe(
                @valueWatcher ?= (value) =>
                    @valueValue = value
                    @setProperty()
            )
        deactivate: ->
            super
            @unobserveKey()
            @unobserveValue()
        setProperty: (key = @keyValue, value = @valueValue) ->
            # we must have a key, and the value must not be undefined UNLESS the value is explicitly undefined!
            if @hasOwnProperty('keyValue') and @hasOwnProperty('valueValue')
                if key? and @context.output?
                    let currentValue = @context.output[key]
                    # we never assign undefined UNLESS it's explicit using the void operator
                    if currentValue isnt value and (value isnt undefined or @valueExpression.operator is 'void')
                        @context.output[key] = value

